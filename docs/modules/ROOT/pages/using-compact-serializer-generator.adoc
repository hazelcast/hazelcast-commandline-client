= Using Compact Serializer Generator

:description: User can generate compact classes for their POJOs using CLC's compact serializer generator feature.
{description}

== Before you Begin

You need the following:

- Hazelcast CLC
- a Hazelcast cluster

== Creating Schemas for Business Objects
Let's assume we have the following entities in our application:

* Student
** ID
** Name
* Classroom
** ID
** Students
* School
** ID
** Classrooms

and their relationship defined as:

* School has classrooms (1->n)
* Classrooms have students (n -> n)

Their schema definitions should be:

[source,yaml]
----
namespace: "com.people"
classes:
  - name: Student
    fields:
      - name: id
        type: int32
      - name: name
        type: string
----

[source,yaml]
----
namespace: "com.rooms"
imports:
  - people.yaml
classes:
  - name: Classroom
    fields:
      - name: id
        type: int32
      - name: students
        type: com.people.Student[]
----

[source,yaml]
----
namespace: "com.education"
imports:
  - classroom.yaml
classes:
  - name: School
    fields:
      - name: id
        type: int32
      - name: classrooms
        type: com.rooms.Classroom[]
----

Schema definitions contains following information:

* described the contents of a compact classes: `Student`, `Classroom`, `School`.
* imported other schema using `imports`.
* specify a namespaces for schema files using `namespace`.

== Generating POJOs and Compact Classes from Schemas

To be able to generate compact classes, following command can be used:

[source,bash]
----
clc serializer generate school.yaml -l java
----

This will generate the classes into the current working directory. If you want to save them to another directory you can append `-o <my_directory>` to the command. After running the command, following classes will be generated:

* `Student.java`
* `School.java`
* `Classroom.java`

User should copy the generated classes to their own packages in their codebase.

== Creating Compact Serialization Configuration

The output of the `generate` command lists configuration options, there are 3 different ways to configure:

* Java Configuration
* XML Configuration
* YAML Configuration

Let's use Java configuration this time and use the following code to register the generated compact classes:

[source,java]
----
ClientConfig clientConfig = new ClientConfig();
clientConfig.getSerializationConfig()
    .getCompactSerializationConfig()
    .setSerializers(new com.rooms.Classroom.Serializer(),
            new com.people.Student.Serializer(),
            new com.education.School.Serializer());
----

== SQL Support

=== Creating Mapping

If map's keys or values have `Compact` format, you need to provide the following additional options while creating the mapping:

* `keyCompactTypeName`
* `valueCompactTypeName`

[source,sql]
----
CREATE OR REPLACE MAPPING students(
     id INT EXTERNAL NAME "__key.id",
     name VARCHAR
) TYPE IMap
OPTIONS (
     'keyFormat' = 'compact',
     'keyCompactTypeName' = 'studentId',
     'valueFormat' = 'compact',
     'valueCompactTypeName' = 'student'
);
----

=== Writing to a Map using Java Client

[source,java]
----
IMap<Integer, Student> studentsMap = client.getMap("students");
Student s1 = new Student(1, "Student1");
studentsMap.put(1, s1);
Student s2 = new Student(2, "Student2");
studentsMap.put(2, s2);
Student s3 = new Student(3, "Student3");
studentsMap.put(3, s3);
----

=== Checking the Created Map Records' Type

[source,bash]
----
clc map entry-set --name students --show-type -f table

 __key | __key_type | this | this_type |      id | name
     3 | INT32      | >    | COMPACT   |       3 | Student3
     2 | INT32      | >    | COMPACT   |       2 | Student2
     1 | INT32      | >    | COMPACT   |       1 | Student1
----

=== Querying the Map using Java Client

[source, java]
----
SqlResult result = sqlService.execute("SELECT this FROM students")
for (SqlRow row : result) {
    Student s = row.getObject("this");
    System.out.println(s.getId())
    System.out.println(s.getName())
}
----